from __future__ import annotations

import json
import pathlib
from dataclasses import dataclass
from typing import Iterable, Iterator, Optional


@dataclass(frozen=True)
class DatasetItem:
    key: str
    path: pathlib.Path
    size_bytes: int


def _cell_key_from_path(p: pathlib.Path) -> str:
    return p.name


def iter_matrix_items(matrix_dir: pathlib.Path) -> Iterator[DatasetItem]:
    """Iter items from a matrix dataset generated by `ncd gen matrix`.

    Expects:
      matrix_dir/matrix.json
      matrix_dir/cells/<cell>/payload.bin

    If matrix.json exists, its cell list is the authoritative ordering.
    """
    matrix_dir = matrix_dir.resolve()
    meta_path = matrix_dir / "matrix.json"
    cells_dir = matrix_dir / "cells"

    if meta_path.exists():
        meta = json.loads(meta_path.read_text(encoding="utf-8"))
        for cell in meta.get("cells", []):
            r = int(cell["row"])
            c = int(cell["col"])
            name = f"r{r:03d}_c{c:03d}"
            p = cells_dir / name / "payload.bin"
            if p.exists():
                yield DatasetItem(key=name, path=p, size_bytes=p.stat().st_size)
        return

    if cells_dir.exists():
        for d in sorted(x for x in cells_dir.iterdir() if x.is_dir()):
            p = d / "payload.bin"
            if p.exists():
                yield DatasetItem(key=_cell_key_from_path(d), path=p, size_bytes=p.stat().st_size)


def load_bytes(path: pathlib.Path, max_bytes: Optional[int] = None) -> bytes:
    b = path.read_bytes()
    if max_bytes is not None:
        return b[: max(0, int(max_bytes))]
    return b


def remaining_sizes(items: Iterable[DatasetItem]) -> list[int]:
    return [int(it.size_bytes) for it in items]
